---
title: 'Lecture #24: Base Graphics I'
author: "Nicholas J. Gotelli"
date: "April 25, 2017"
output:
  html_document:
    highlight: tango
    theme: united
  pdf_document: default
---
### Preserving Defaults, Attaching A Data Frame

```{r eval=TRUE}
####################################################
#  Standard calls for preserving defaults, and reading a csv
par() # a ridiculous number of graphic parameters
opar <- par(no.readonly=TRUE) # store defaults of changeable options
Ant.Data <- read.table(file="antcountydata.csv",
                       header=TRUE,
                       sep=",",
                       stringsAsFactors=FALSE)
attach(Ant.Data) # to cut down on typing of data frame name
```

### Basic Graphs & Lines

```{r, eval=TRUE}

plot(x=lat.centroid,y=n.species,log="y") # log transforms; use x,y, or xy
plot(x=lat.centroid,y=n.species)
abline(h=20) # drawing a horizontal line
abline(v=46,lwd=2,lty="twodash",col="grey") # drawing a vertical line
abline(a=-1600,b=40) # intercept and slope
abline(lm(n.species~lat.centroid)) # standard regression
lines(lowess(n.species~lat.centroid),col="blue",lty="dotdash",lwd=2.5)
rug(lat.centroid) # show the density of data points
rug(n.species,side=2) # can be done on any axis for any variable
grid()
box(which="outer") # box options: outer, inner, figure, plot
box(col="gray",lwd=5)
text(44,60,"my text here at 44,60")
```

### Standard Axes

```{r, eval=TRUE}
par(opar)
x <- 1:1000
y <- runif(1000,0.2)
plot(x,y,type="l",col="grey",ylim=c(0,1.2))
grid(nx=NA,ny=NULL,col="black")

# adjustments for standard axes

# use  xlim and y lim for clipping or adding white space
plot(x,y,type="l",col="grey",xlim=c(400,600),ylim=c(-1,1))

# use xlim and ylim reversed to flip axes
plot(x,y,,type="l",col="grey",xlim=c(1000,0))

# use lab for ticks x,y, len of label (default=7)
plot(x,y,type="l",col="grey",ylim=c(0,1.2),
     lab=c(1,5,7))

# use mgp for lines of text from edge. 3 numbers are:
# 1) margin label; 2) tick mark labels; 3) axis line
# defaults are 3,1,0

plot(x,y,type="l",col="grey",ylim=c(0,1.2),
     mgp=c(0,1,0)) # pulls in label

plot(x,y,type="l",col="grey",ylim=c(0,1.2),
     mgp=c(3,-1,0)) # pulls in label to inside


plot(x,y,type="l",col="grey",ylim=c(0,1.2),
     mgp=c(3,1,1)) # moves out entire axis

# use tcl to control length and direction of ticks; default=-0.5
plot(x,y,type="l",col="grey",ylim=c(0,1.2),
     tcl=1,lab=c(5,5,7))

# could pull in labels and use inner tick marks
# use las to flip tick labels to all horizontal
plot(x,y,type="l",col="grey",xlim=c(-40,1000),ylim=c(0.17,1),
     tcl=0.3,mgp=c(2,0.2,0),las=1,ann=FALSE,bty="L")

# use xlog in par or log in plot for transform
plot(x,y,type="l",col="grey",log="x")

# use xaxs and yaxs to control style of axis setting
# default = r = expanded range
# or set as i = exact range

par(pty="s")
par(mfrow=c(2,1))
par(mar=c(2,2,1,1))
plot(x,y,type="l",col="grey",ann=FALSE,xaxs="r")
plot(x,y,type="l",col="grey",ann=FALSE,xaxs="i")

```

### Custom Axes

```{r, eval=TRUE}
par(opar)
# create random data with gamma distribution
x <- 1:20
y <- rgamma(20,1,2)

# set x limit to avoid clipping at start
par(mar=c(5,4,4,4))
plot(x,y,type="b",pch=23,bg="slateblue",
     xlim=c(0,20),ylim=c(0,1.3),
     axes=FALSE,ann=FALSE)

# use sequence and take default tick labels
axis(1,at=seq(0,20,by=5))

# use mtext to add text labels in the margins
mtext("Time",1,line=3)

# use sequence and override with user labels
axis(2, at=seq(0,1.3,length=4),labels=c("low","med","high","peak"),
     las=2)

# thicken up tick lines and move axis out a bit
axis(3,at=seq(0,20,by=5),line=1,lwd=2,lwd.ticks=2,font=2)

# move the axis and ticks inward with the mgp argument
axis(4,at=seq(0,1.3,length=4),labels=c("l","m","h","p"),
     las=2,mgp=c(0,1.4,1.9),tcl=2,
     col.axis="red",col="slateblue")

# overplot the axis to easily create minor tick marks
axis(4,at=seq(0,1.3,length=7),labels=FALSE,
     mgp=c(0,1.4,1.9),tcl=0.75,
     col="slateblue")
par(opar)
```

### Cleaned Up Regression

```{r, eval=TRUE}
par(mar=c(5,6,2,2)+0.1)
plot(x=lat.centroid,y=n.species,
     xlab="Latitude",ylab="Number of Species",
     las=1,cex.axis=1.2,cex.lab=1.5)
reg.model <- lm(n.species~lat.centroid)
abline(reg.model)
rug(n.species,side=2)
grid()
```

### Text Annotations

```{r, eval=TRUE}
x <- 1:5
y <- seq(1,5,1)
plot(x,y)
text(1,1,"right",pos=4) # use pos to offset the text
# use vectors for multiple plotting
plot(x,y,ann=FALSE, axes= FALSE, col="green")
box(col="gray")
text(x[-3],y[-3],c("right","top","bottom","left"),pos=c(4,3,1,2))
text(3,3,"overlay")
text(4,2,"angle = 10 degrees",srt=10)

# illustration of plot math
plot(x,y,ann=FALSE, axes= FALSE, type="n")
box(col="gray")

text(3,4,
     expression(sqrt(x[i]^2+y[i]^2)-hat(beta)))


 text(3,3,
      expression(bar(x) == sum(frac(x[i], n),
                 i == 1,n)))
 
# alter size, color, font, and rotation
 text(3,3,
      expression(bar(x) == sum(frac(x[i], n),
                 i == 1,n)),
      cex=4,col="red",font=1,srt=-10)
 
text(3,2,
     expression(paste("Temperature (", degree,
                      "C) in 2013")))
```

### Graphical Annotations

```{r, eval=TRUE}
x <- 1:10
y <-runif(10)

plot(x,y,type="n",xlim=c(0,10),ylim=c(0,1))

points(x,y)
lines(x,y)

xspline(x,y,shape=0) # -1,0,1
xspline(x,y,shape=1,open=FALSE)
polygon(x,y,col="coral")

rect(8,0.1,10,0.2,col="blue")
rect(0,0,x,y,lty="dashed")
segments(0,1,3,0)
segments(0,0,x,y)
arrows(0,0,x,y)
points(0,0)
```

### Clean Up & Detach

```{r, eval=TRUE}

detach(Ant.Data) # detach ant data
par(opar) # restore original parameters
```

### Panel Layout & 4 Variations On Plot Type

```{r, eval=TRUE}
####################################################
# illustrating panel layout and 4 variations on plot type
Random.Data <- rnorm(20)
time <- 1:20
par(mfrow=c(3,2))
plot(Random.Data,type="p")
plot(Random.Data,type="l")
plot(Random.Data,type="b")
plot(Random.Data,type="o")
plot(Random.Data,type="s")
plot(Random.Data,type="h")

par(opar)
plot(Random.Data,type="n")
```

### Special Plots With Linear Model

```{r, eval=TRUE}
attach(Ant.Data)
####################################################
# illustrating special plots that come with a linear model
par(mfrow=c(2,2))
Ant.Model <- lm(n.species~lat.centroid)
summary(Ant.Model)
plot(Ant.Model)
plot(lat.centroid,n.species)
abline(Ant.Model)
abline(h=10,lty="dashed")
abline(v=45,col="red",lty="dotdash")
```

### Plots In A Single Dimension

```{r, eval=TRUE}
# illustrating plots for a single dimension of data
par(mfrow=c(1,2))

plot(n.species) # plots numeric data in order
plot(table(ecoregion)) # plots tabled counts of factors as lines

barplot(table(ecoregion))
Little.Data <- c(3,2,1,5,6)
names(Little.Data) <- LETTERS[1:5]
barplot(Little.Data) # plots numeric data as bar heights

pie(Little.Data) # plots numeric data as pie slices     
dotchart(Little.Data) # plots numeric data as ordered dot plots

boxplot(n.species) # plots numeric data as box plot
hist(n.species) # plots numeric data as histogram
stripchart(Little.Data) # plots numeric data in a single strip chart
plot(density(n.species)) # plots kernel density of a numeric variable

```

### Bar Plot With Custom Error Bars

```{r, eval=TRUE}
ecoregion.means <- by(n.species,ecoregion,mean)

barplot(ecoregion.means,names.arg=letters[1:5],
        ylim=c(0,100))
midpoints <- barplot(ecoregion.means,plot=FALSE)
ecoregion.sd <- by(n.species,ecoregion,sd)

arrows(midpoints,ecoregion.means,midpoints,
       ecoregion.means+ecoregion.sd,angle=90,
       length=0.1)

# For a double-headed arrow, adjust starting
# points and use code=3
arrows(midpoints,ecoregion.means-ecoregion.sd,midpoints,
       ecoregion.means+ecoregion.sd,angle=90,
       length=0.1,code=3)
points(midpoints,ecoregion.means,pch=19)

# plotting points with asymmetric
# confidence intervals
par(opar)

# using the quantile function
z <- rnorm(1000)
quantile(z,probs=0.95)
hist(z)
abline(v=quantile(z,probs=c(0.05,0.95)),lty="dashed",col="red")
abline(v=quantile(z,probs=c(0.025,0.975)),lty="dotted",col="blue")

# Calculate Confidence intervals with the by function
quantile(n.species,probs=0.025)
Con.low <- by(n.species,ecoregion,quantile,probs=0.025)
Con.high <- by(n.species,ecoregion,quantile,probs=0.975)

# set up a blank plot (show code first)
plot(1:5,1:5)
plot(1:5,1:5,xlim=c(0.5,5),ylim=c(0,100))
plot(1:5,1:5,xlim=c(0.5,5),ylim=c(0,100),type="n")

# fully blank plot
plot(1:5,1:5,xlim=c(0.5,5),ylim=c(0,100),type="n",
     ,axes= FALSE,ann=FALSE)

# add axes with labels
axis(1,at=seq(1:5),labels=letters[1:5])
axis(2)
mtext("Number of Species",side=2,line=2.5)
box(bty="L")
arrows(1:5,ecoregion.means,1:5,Con.low,angle=90,length=0.1)
arrows(1:5,ecoregion.means,1:5,Con.high,angle=90,length=0.1)
points(1:5,ecoregion.means,pch=23,cex=1.5,bg="gold")
abline(h=seq(0,100,by=20),col="gray",lty="dotted")

# add minor tick marks
# first find your location in the plot
points(1,0)
points(0,0)
points(0.5,0)
par("usr") # get limits

# try plotting a point points(0.32,10)
points(0.32,10)
par("xpd")
par(xpd=TRUE) # change clippig to figure region
points(0.32,10)
# first refresh plot
segments(rep(0.32,5),seq(10,90,length=5),rep(0,5),seq(10,90,length=5))
```

### Regression Line With Confidence, Prediction Intervals

```{r, eval=TRUE}
##########################################
# fit the model

reg.model <- lm(mean.ann.temp~lat.centroid)

#################################################
# confidence and prediction intervals for original data

con.1 <- predict(reg.model,interval="confidence")
pred.1 <- predict(reg.model,interval="prediction")

####################################################
# confidence and prediction intervals for new x data
# (extrapolation and more finely spaced x)


nd <- seq(35,50,length=100)

con.2 <- predict(reg.model,interval="confidence",
                 newdata=data.frame(lat.centroid=nd))

pred.2 <- predict(reg.model,interval="prediction",
                  newdata=data.frame(lat.centroid=nd))

#####################################################
# plot results just for data interval

plot(lat.centroid,mean.ann.temp)
abline(reg.model)

matlines(Ant.Data$lat.centroid,con.1[,c("lwr","upr")],
         col="red",lty=1,type="l")

matlines(Ant.Data$lat.centroid,pred.1[,c("lwr","upr")],
         col="blue",lty=1,type="l")

##################################################
# plot results for extrapolated interval and smooth data
plot(lat.centroid,mean.ann.temp,xlim=c(30,50),ylim=c(-5,15))

abline(reg.model)

matlines(nd,con.2[,c("lwr","upr")],
         col="red",lty=1,type="l")

matlines(nd,pred.2[,c("lwr","upr")],
         col="blue",lty=1,type="l")

###########################################################
# plot the results as a confidence band using a polygon

plot(lat.centroid,mean.ann.temp,
     xlim=c(34,50),ylim=c(-5,25),type="n")

polygon(c(nd,rev(nd)),c(con.2[,2],rev(con.2[,3])),
        col="thistle",border=NA)

points(lat.centroid,mean.ann.temp)

abline(reg.model)

##########################################################
# plot the results as a prediction band using a polygon

plot(lat.centroid,mean.ann.temp,
     xlim=c(34,50),ylim=c(-5,25),type="n")

polygon(c(nd,rev(nd)),c(pred.2[,2],rev(pred.2[,3])),
        col="wheat",border=NA)

points(lat.centroid,mean.ann.temp)
abline(reg.model)

#########################################################
```

### Layout Function For Visualizing Plot Space

```{r, eval=TRUE}
#############################################
# Creating a function for illustrating plot layouts
my.layout <- function (x=1) {
  for (i in 1:x) plot(runif(100),type="b",
  col="gray",lwd=2,ann=FALSE,las=1)
  
  mtext("X axis label",side=1,font=2,line=3)
  mtext("Y axis label",side=2,font=2,line=3)
  mtext("Top Plot label",side=3,font=2,line=1)
  mtext("Side\nPlot\nLabel",side=4,font=2,line=1,las=1)
  mtext("BOTTOM OUTER MARGIN LABEL",side=1,font=2,line=1,cex=2,outer=TRUE)
  mtext("SIDE OUTER MARGIN LABEL",side=2,font=2,line=1,cex=2,outer=TRUE)
  mtext("TOP OUTER MARGIN LABEL",side=3,font=2,line=1,cex=2,outer=TRUE)
  mtext("SIDE\nOUTER\nMARGIN\nLABEL",side=4,font=2,line=1,cex=2,outer=TRUE,las=1)
   
  box(which="outer",col="red",lwd=4)
  box(which="inner",col="blue",lwd=4)
  box(which="figure",col="darkgreen",lwd=4)
  box(which="plot",col="goldenrod",lwd=4)
  
  par(opar)
}
############################################
# Check out appearance with default settings

my.layout(1)

##########################################
# Adjusting Margins of a Single Figure with mar (= lines of text)

par("mar")

par(mar=c(5,5,4,4))
my.layout(1)

##########################################
# Adding outer plot margins with oma (= lines of text)

par("oma")

par(oma=c(3,3,3,8))
my.layout(1)

##########################################

# Creating a square plot with pty (default = "m")

par("pty")
par(pty="s")

my.layout(1)

########################################
# Using mfrow for multi-panel plots

par("mfrow")
par(mfrow=c(3,2))
my.layout(6)

# Add in your outer margins & square plot regions

par("oma")
par(oma=c(6,6,6,6))
par(pty="s")
par(mar=c(2,2,2,2))
par(mfrow=c(3,4))
my.layout(12)

###############################################
# Gaining more control with the layout function

layout(matrix(1:6,nrow=3,byrow=TRUE))
layout.show(6)
my.layout(6)

# Matrix elements give the order of filling
layout(matrix(c(1,2,3,4,6,5),nrow=3,byrow=FALSE))
layout.show(6)
my.layout(6)

###########################################
# as before, outer margins can be added

layout(matrix(1:6,nrow=3,byrow=TRUE))
layout.show(6)
par("oma")
par(oma=c(4,4,4,4))
layout.show(6)
my.layout(6)

##################################################
# use "respect" option to square up the entire figure region

layout(matrix(1:6,nrow=3,byrow=TRUE),respect=TRUE)
layout.show(6)

par(oma=c(4,4,4,4))
layout.show(6)
my.layout(6)

###################################################
# allows for more compact figures; use with pty="s"

layout(matrix(1:12,nrow=3,byrow=TRUE),respect=TRUE)
layout.show(12)

par(oma=c(4,4,4,4))
par(mar=c(2,2,2,2))
par(pty="s")

layout.show(12)
my.layout(12)

###################################################
# alter the widths and/or heights of figures

layout(matrix(1:6,nrow=3,byrow=TRUE),widths=c(2,1))
layout.show(6)
my.layout(6)

layout(matrix(1:6,nrow=3,byrow=TRUE),widths=c(2,1),
heights=c(1,2,1))
layout.show(6)
my.layout(6)

###################################################
# use "0" matrix entries for no plot
# use multiple matrix entries for expanded plot regions

layout(matrix(c(1,1,1,2,0,3),nrow=2,byrow=TRUE))
layout.show(3)
my.layout(6)

###################################################
# use all of this to combine graphic elements

# set up plotting regions

par(opar)
layout(matrix(c(2,0,1,3),nrow=2,byrow=TRUE),
              heights=c(1,8),widths=c(8,1))
layout.show(3)
########################################################
# create some skewed data and sort it
x <- sort(rgamma(100,shape=2,scale=1))
y <- sort(rgamma(100,shape=2,scale=1),decreasing=TRUE)

########################################################
# generate the basic scatterplot
par(mar=c(4,5,0,0))
plot(x,y,ann=FALSE,cex=2,pch=21,bg="cornflowerblue")

par(mar=c(0,5,0,0))
#par(bty="n")
#par(xaxt="n")


boxplot(x,names=FALSE,horizontal=TRUE,col="cornflowerblue")
par(mar=c(4,0,0,0))

#par(yaxt="n")
boxplot(y,names=FALSE, horizontal=FALSE,col="cornflowerblue")
par(opar)
```
### Asymmetric Confidence Intervals

```{r, eval=TRUE}
ecoregion.means <- by(n.species,ecoregion,mean)

# using the quantile function
z <- rnorm(1000)
quantile(z,probs=0.95)
hist(z)
abline(v=quantile(z,probs=c(0.05,0.95)),lty="dashed",col="red")
abline(v=quantile(z,probs=c(0.025,0.975)),lty="dotted",col="blue")

# Calculate Confidence intervals with the by function
quantile(n.species,probs=0.025)
Con.low <- by(n.species,ecoregion,quantile,probs=0.025)
Con.high <- by(n.species,ecoregion,quantile,probs=0.975)

# set up a blank plot (show code first)
plot(1:5,1:5)
plot(1:5,1:5,xlim=c(0.5,5),ylim=c(0,100))
plot(1:5,1:5,xlim=c(0.5,5),ylim=c(0,100),type="n")

# fully blank plot
plot(1:5,1:5,xlim=c(0.5,5),ylim=c(0,100),type="n",
     ,axes= FALSE,ann=FALSE)

# add axes with labels
axis(1,at=seq(1:5),labels=letters[1:5])
axis(2)
mtext("Number of Species",side=2,line=2.5)
box(bty="L")


arrows(1:5,ecoregion.means,1:5,Con.low,angle=90,length=0.1)
arrows(1:5,ecoregion.means,1:5,Con.high,angle=90,length=0.1)
points(1:5,ecoregion.means,pch=23,cex=1.5,bg="gold")
abline(h=seq(0,100,by=20),col="gray",lty="dotted")

# add minor tick marks
# first find your location in the plot
points(1,0)
points(0,0)
points(0.5,0)
par("usr") # get limits

# try plotting a point points(0.32,10)
points(0.32,10)
par("xpd")
par(xpd=TRUE) # change clippig to figure region
points(0.32,10)
# first refresh plot
segments(rep(0.32,5),seq(10,90,length=5),rep(0.28,5),seq(10,90,length=5))
par(opar)
```
### Polygon Confidence Interval
```{r, eval=TRUE}
par(mar=c(5,6,4,2)+0.1)
par(pty="s")

# create data
x <- 1:100
Exp <- 50 + x*0.1
Con.High <- Exp + 5 + rnorm(100)
Con.Low <- Exp - 5 + rnorm(100)
One.Run <- Exp + rnorm(100,0,2)

# create plot
plot(Exp~x,type="l",
     xlab= "Time Step",
     ylab="Populatioh Size (N)",
     lty="dashed",
     ylim=range(One.Run,Exp,Con.High,Con.Low),
     cex.lab=1.5,las=1,cex.axis=1.5)

# add polygon and overplot the lines
polygon(c(x,rev(x)),c(Con.Low,rev(Con.High)),col="thistle",border=NA)
lines(x,Exp,lty="solid",col="purple",lwd=1.5)
lines(x,One.Run)
par(opar)

```

### Color

```{r, eval=TRUE}
######################################################################
par(opar)
# names and units for colors
# colors()
colors()[10]
col2rgb("red")
z <- "#DD059E"
pie(1,col=z)

######################################################################

Ant.Data$custom.colors <- NA


# new colors (could be numbers)
mycolors <- c("green","yellow","purple","blue","grey")
table(ecoregion)

as.integer(as.factor(ecoregion))

Ant.Data$custom.colors <- 
  mycolors[as.integer(as.factor(Ant.Data$ecoregion))]

plot(mean.ann.temp,n.species,col=Ant.Data$custom.colors,
main="using custom color vector")

#######################################################################
# using the cut function to create categories for colors

# cut the temperature variable

Temperature.Colors <- c("yellow","orange",
                        "red","chocolate")
temp <- 
  cut(mean.ann.temp,breaks=quantile(mean.ann.temp,
      c(0,0.25,0.5,0.75,1.0)), include.lowest=TRUE,
                                    labels=FALSE)



Ant.Data$T.colors <- Temperature.Colors[temp]

plot(lat.centroid,mean.ann.temp,pch=24,
     bg=Ant.Data$T.colors,cex=2)

###############################################
# adjusting colors for transparency
# first, with no adjustment
x1 <- rnorm(100,0,1)
x2 <- rnorm(100,2,1)

hist(x1,xlim=range(c(x1,x2)),ylim=c(0,35),
     col="red",breaks=seq(-4,6,by=0.5))
par(new="TRUE")

hist(x2,xlim=range(c(x1,x2)), ylim=c(0,35),
     axes=FALSE,ann=FALSE,
     col="blue",breaks=seq(-4,6,by=0.5))
par(opar)

# now adjust the blue to 50% transparency
my.blue <- adjustcolor("blue",alpha.f=0.5)

hist(x1,xlim=range(c(x1,x2)),ylim=c(0,35),
     col="red",breaks=seq(-4,6,by=0.5))

par(new="TRUE")

hist(x2,xlim=range(c(x1,x2)), ylim=c(0,35),
     axes=FALSE,ann=FALSE,col=my.blue,
     breaks=seq(-4,6,by=0.5)) # my.blue not in quotes!

par(opar)
###########################################
# visualizing colors from default color sets

n <- 3
my.greys <- gray.colors(n,0,1)
pie(rep(1,n),labels=my.greys,col=my.greys)

my.rainbow <- rainbow(n)
pie(rep(1,n),labels=my.rainbow,col=my.rainbow)

############################################
# build your own function

Color.Pie <- function(z="black"){
  pie(rep(1,length(z)),col=z)
}
###########################################
Color.Pie()
x <- rainbow(10)
Color.Pie(x)
x <- rainbow(3)
barplot(c(3,4,1),col=x)

palette(rainbow(5))
palette()
palette("default")

# use start and stop to control range in rainbow
# defaults are 0 to 1
x <- rainbow(10,start=0.2,end=0.7)

# use s and v for saturation and value in rainbow
# default is 1
x <- rainbow(10,s=0.5)
x <- rainbow(10,v=0.8)
Color.Pie(x)
# specify alpha value for transparency
# default is 1 (= opaque)
x <- rainbow(10,alpha=0.5)

# other built in palettes only can specify alpha
x <- heat.colors(10)
x <- terrain.colors(10)
x <- topo.colors(10)
x <- cm.colors(10)


Color.Pie(x)

# special calls for grays

x <- gray.colors(10) # default grays
x <- gray.colors(10,0,1) # from white through black
xs <- x[c(2,9,4)] # take a re-ordered subset

Color.Pie(xs)
############################################################
# Using the ColorBrewer library and associated palettes

library(RColorBrewer)
display.brewer.all(type="all")

x <- brewer.pal(6,"Reds") # gradients
x <- brewer.pal(10,"Spectral") #divergent
x <- brewer.pal(8,"Dark2") # contrasting

Color.Pie(x)
############################################################
par(opar)
```

#### Default Color Mappings For `ggplot`

Here is a function to derive the default color values that ggplot provides. That way they can be modified for subsets. Create a function to get the evenly spaced colors for whatever level is specified in a category for ggplot:

```{r, eval=TRUE}
gg_color_hue <- function(n) {
  hues <- seq(15,375,length=n+1)
  hcl(h=hues,l=65,c=100)[1:n]
}
```

Now call it and plot it:

```{r,eval=TRUE}
n <- 4
cols <- gg_color_hue(n)
print(cols)
plot(1:n, pch=16,col=cols,cex=5)
```


Note the following HCL color specification information:

```
Usage

hcl(h = 0, c = 35, l = 85, alpha, fixup = TRUE)
Arguments

h	
The hue of the color specified as an angle in the range [0,360]. 0 yields red, 120 yields green 240 yields blue, etc.

c	
The chroma of the color. The upper bound for chroma depends on hue and luminance.

l	
A value in the range [0,100] giving the luminance of the colour. For a given combination of hue and chroma, only a subset of this range is possible.

alpha	
numeric vector of values in the range [0,1] for alpha transparency channel (0 means transparent and 1 means opaque).

fixup	
a logical value which indicates whether the resulting RGB values should be corrected to ensure that a real color results. if fixup is FALSE RGB components lying outside the range [0,1] will result in an NA value.
```

#### `colorRampPaletteAlpha()` and `addalpha()` 

- helper functions for adding transparency to colors in R
- blog post by Myles Harrison


```{r, eval=TRUE}
# addalpha()
addalpha <- function(colors, alpha=1.0) {
  r <- col2rgb(colors, alpha=T)
  # Apply alpha
  r[4,] <- alpha*255
  r <- r/255.0
  return(rgb(r[1,], r[2,], r[3,], r[4,]))
}

# colorRampPaletteAlpha()
colorRampPaletteAlpha <- function(colors, n=32, interpolate='linear') {
  # Create the color ramp normally
  cr <- colorRampPalette(colors, interpolate=interpolate)(n)
  # Find the alpha channel
  a <- col2rgb(colors, alpha=T)[4,]
  # Interpolate
if (interpolate=='linear') {
l <- approx(a, n=n)
} else {
l <- spline(a, n=n)
}
l$y[l$y > 255] <- 255 # Clamp if spline is > 255
cr <- addalpha(cr, l$y/255.0)
return(cr)
}
```

`colorRampPalette` is a very useful function in R for creating colors vectors to use as the palette, or to pass as an argument to a plotting function; however, a weakness lies in that it disregards the alpha channel of the colors passed to it when creating the new vector.

I have also found that working with the alpha channel in R is not always the easiest, but is something that scientists and analysts may often have to do - when overplotting, for example.

To address this I've quickly written the helper functions `addalpha` and `colorRampPaletteAlpha`, the former which makes passing a scalar or vector to a vector of colors as the alpha channel easier, and the latter as a wrapper for colorRampPalette which preserves the alpha channel of the colors provided.

Using the two functions in combination it is easy to produce plots with variable transparency such as in the figure below:

```{r, eval=TRUE}
# addalpha() and colorRampPaletteAlpha() usage examples
# Myles Harrison
# www.everydayanalytics.ca

library(MASS)
library(RColorBrewer)
# Source the colorRampAlpha file
#source ('colorRampPaletteAlpha.R')

# addalpha()
# ----------
# scalars:
col1 <- "red"
col2 <- rgb(1,0,0)
addalpha(col2, 0.8)
addalpha(col2,0.8)

# scalar alpha with vector of colors:
col3 <- c("red", "green", "blue", "yellow")
addalpha(col3, 0.8)
plot(rnorm(1000), col=addalpha(brewer.pal(11,'RdYlGn'), 0.5), pch=16)

# alpha and colors vector:
alpha <- seq.int(0, 1, length.out=4)
addalpha(col3, alpha)

# Simple example
x <- seq.int(0, 2*pi, length=1000)
y <- sin(x)
plot(x, y, col=addalpha(rep("red", 1000), abs(sin(y))))

# with RColorBrewer
x <- seq.int(0, 1, length.out=100)
z <- outer(x,x)
c1 <- colorRampPalette(brewer.pal(11, 'Spectral'))(100)
c2 <- addalpha(c1,x)
par(mfrow=c(1,2))
image(x,x,z,col=c1)
image(x,x,z,col=c2)

# colorRampPaletteAlpha()
# Create normally distributed data
x <- rnorm(1000)
y <- rnorm(1000)
k <- kde2d(x,y,n=250)

# Sample colors with alpha channel
col1 <- addalpha("red", 0.5)
col2 <-"green"
col3 <-addalpha("blue", 0.2)
cols <- c(col1,col2,col3)

# colorRampPalette ditches the alpha channel
# colorRampPaletteAlpha does not
cr1 <- colorRampPalette(cols)(32)
cr2 <- colorRampPaletteAlpha(cols, 32)

par(mfrow=c(1,2))
plot(x, y, pch=16, cex=0.3)
image(k$x,k$y,k$z,col=cr1, add=T)
plot(x, y, pch=16, cex=0.3)
image(k$x,k$y,k$z,col=cr2, add=T)

# Linear vs. spline interpolation
cr1 <- colorRampPaletteAlpha(cols, 32, interpolate='linear') # default
cr2 <- colorRampPaletteAlpha(cols, 32, interpolate='spline')
plot(x, y, pch=16, cex=0.3)
image(k$x,k$y,k$z,col=cr1, add=T)
plot(x, y, pch=16, cex=0.3)
image(k$x,k$y,k$z,col=cr2, add=T)
```

#### Useful Color Palettes

This is some material pasted from a blog [The Paul Tol 21-color salute](http://www.r-bloggers.com/the-paul-tol-21-color-salute/) with useful color palettes.

You may or may not know that PerformanceAnalytics contains a number of specific color schemes designed for charting data in R (they aren’t documented well, but they show up in some of the chart examples). I’ve been collecting color palates for years in search of good combinations of attractiveness, relative weight, and distinctiveness, helped along the way by great sites like ColorBrewer and packages like RColorBrewer.   I’ve assembled palettes that work for specific purposes, such as the color-focus palates (e.g., redfocus is red plus a series of dark to light gray colors). Others, such as rich#equal, provide a palette for displaying data that all deserve equal treatment in the chart. Each of these palettes have been designed to create readable, comparable line and bar graphs with specific objectives outlined before each category below.

I use this approach rather than generating schemes on the fly for two reasons: it creates fewer dependencies on libraries that don’t need to be called dynamically; and to guarantee the color used for the n-th column of data.

```{r eval=TRUE}
# Function for plotting colors side-by-side
# Written by Adam Zeileis in the color.space package
pal <- function(col=c("goldenrod","mediumorchid","coral"), border = "light gray", ...){
  n <- length(col)
  plot(0, 0, type="n", xlim = c(0, 1), ylim = c(0, 1),
       axes = FALSE, xlab = "", ylab = "", ...)
  rect(0:(n-1)/n, 0, 1:n/n, 1, col = col, border = border)
  }
pal()
```

**Focus Palettes**
The Focus palettes are colorsets designed to provide focus to the data graphed as the first element. These palettes are best used when there is clearly an important data set for the viewer to focus on, with the remaining data being secondary, tertiary, etc. Later elements are shown in diminishing values of gray. These were generated with RColorBrewer, using the 8 level “grays” palette and replacing the darkest gray with the focus color.

```{r, eval=TRUE}
# FOCUS PALETTES
# Red as highlight
redfocus = c("#CB181D", "#252525", "#525252", "#737373", "#969696", "#BDBDBD", "#D9D9D9", "#F0F0F0")
 
# Green as highlight
greenfocus = c("#41AB5D", "#252525", "#525252", "#737373", "#969696", "#BDBDBD", "#D9D9D9", "#F0F0F0")
 
# Blue as highlight
bluefocus = c("#0033FF", "#252525", "#525252", "#737373", "#969696", "#BDBDBD", "#D9D9D9", "#F0F0F0")
 
pal(greenfocus)
```

**Equal Weights Palettes**
Equal Weight palettes colorsets are fine for when all of the data should be distinguishable and carry similar weight, such as on a line graph or bar plot. The different numbers in the name indicate the number of colors generated (six colors is probably the maximum for a completely readable linegraph).

```{r,eval=TRUE}
# EQUAL WEIGHT
# Generated with rainbow(12, s = 0.6, v = 0.75)
rainbow12equal = c("#BF4D4D", "#BF864D", "#BFBF4D", "#86BF4D", "#4DBF4D", "#4DBF86", "#4DBFBF", "#4D86BF", "#4D4DBF", "#864DBF", "#BF4DBF", "#BF4D86")
rainbow10equal = c("#BF4D4D", "#BF914D", "#A8BF4D", "#63BF4D", "#4DBF7A", "#4DBFBF", "#4D7ABF", "#634DBF", "#A84DBF", "#BF4D91")
rainbow8equal = c("#BF4D4D", "#BFA34D", "#86BF4D", "#4DBF69", "#4DBFBF", "#4D69BF", "#864DBF", "#BF4DA3")
rainbow6equal = c("#BF4D4D", "#BFBF4D", "#4DBF4D", "#4DBFBF", "#4D4DBF", "#BF4DBF")
 
# Generated with package "gplots" function rich.colors(12)
rich12equal = c("#000040", "#000093", "#0020E9", "#0076FF", "#00B8C2", "#04E466", "#49FB25", "#E7FD09", "#FEEA02", "#FFC200", "#FF8500", "#FF3300")
rich10equal = c("#000041", "#0000A9", "#0049FF", "#00A4DE", "#03E070", "#5DFC21", "#F6F905", "#FFD701", "#FF9500", "#FF3300")
rich8equal = c("#000041", "#0000CB", "#0081FF", "#02DA81", "#80FE1A", "#FDEE02", "#FFAB00", "#FF3300")
rich6equal = c("#000043", "#0033FF", "#01CCA4", "#BAFF12", "#FFCC00", "#FF3300")
 
# Generated with package "fields" function tim.colors(12), which is said to emulate the default matlab colorset
tim12equal = c("#00008F", "#0000EA", "#0047FF", "#00A2FF", "#00FEFF", "#5AFFA5", "#B5FF4A", "#FFED00", "#FF9200", "#FF3700", "#DB0000", "#800000")
tim10equal = c("#00008F", "#0000FF", "#0070FF", "#00DFFF", "#50FFAF", "#BFFF40", "#FFCF00", "#FF6000", "#EF0000", "#800000")
tim8equal = c("#00008F", "#0020FF", "#00AFFF", "#40FFBF", "#CFFF30", "#FF9F00", "#FF1000", "#800000")
tim6equal = c("#00008F", "#005AFF", "#23FFDC", "#ECFF13", "#FF4A00", "#800000")
 
# Generated with sort(brewer.pal(8,"Dark2")) #Dark2, Set2
dark8equal = c("#1B9E77", "#666666", "#66A61E", "#7570B3", "#A6761D", "#D95F02", "#E6AB02", "#E7298A")
dark6equal = c("#1B9E77", "#66A61E", "#7570B3", "#D95F02", "#E6AB02", "#E7298A")
set8equal = c("#66C2A5", "#8DA0CB", "#A6D854", "#B3B3B3", "#E5C494", "#E78AC3", "#FC8D62", "#FFD92F")
set6equal = c("#66C2A5", "#8DA0CB", "#A6D854", "#E78AC3", "#FC8D62", "#FFD92F")
 
pal(rich8equal)
pal(tim12equal)
pal(dark6equal)
pal(set8equal)
```

**Monochrome Palettes**
The last category are Monochrome palettes, which I like in both stacked bar plots and with a few lines.

```{r}
# MONOCHROME PALETTES
# sort(brewer.pal(8,"Greens"))
redmono = c("#99000D", "#CB181D", "#EF3B2C", "#FB6A4A", "#FC9272", "#FCBBA1", "#FEE0D2", "#FFF5F0")
greenmono = c("#005A32", "#238B45", "#41AB5D", "#74C476", "#A1D99B", "#C7E9C0", "#E5F5E0", "#F7FCF5")
bluemono = c("#084594", "#2171B5", "#4292C6", "#6BAED6", "#9ECAE1", "#C6DBEF", "#DEEBF7", "#F7FBFF")
grey8mono = c("#000000","#252525", "#525252", "#737373", "#969696", "#BDBDBD", "#D9D9D9", "#F0F0F0")
grey6mono = c("#242424", "#494949", "#6D6D6D", "#929292", "#B6B6B6", "#DBDBDB")
 
pal(bluemono)
pal(redmono)
```

A while ago I decided that none of these schemes was quite discernable enough for what I needed to do. I frequently display line graphs that require the reader to differentiate among the colors, and sometimes I need more differentiable colors than is advisable. I did a bit of hunting around and came across [Paul Tol’s SRON Technical Note](http://www.sron.nl/~pault/colourschemes.pdf) and have since been using his color schemes for qualitative data, which are nicely distinctive and come with more combinations than many of the best ColorBrewer sets.

```{r, eval=TRUE}
# Qualitative color schemes by Paul Tol
 tol1qualitative=c("#4477AA")
 tol2qualitative=c("#4477AA", "#CC6677")
 tol3qualitative=c("#4477AA", "#DDCC77", "#CC6677")
 tol4qualitative=c("#4477AA", "#117733", "#DDCC77", "#CC6677")
 tol5qualitative=c("#332288", "#88CCEE", "#117733", "#DDCC77", "#CC6677")
 tol6qualitative=c("#332288", "#88CCEE", "#117733", "#DDCC77", "#CC6677","#AA4499")
 tol7qualitative=c("#332288", "#88CCEE", "#44AA99", "#117733", "#DDCC77", "#CC6677","#AA4499")
 tol8qualitative=c("#332288", "#88CCEE", "#44AA99", "#117733", "#999933", "#DDCC77", "#CC6677","#AA4499")
 tol9qualitative=c("#332288", "#88CCEE", "#44AA99", "#117733", "#999933", "#DDCC77", "#CC6677", "#882255", "#AA4499")
 tol10qualitative=c("#332288", "#88CCEE", "#44AA99", "#117733", "#999933", "#DDCC77", "#661100", "#CC6677", "#882255", "#AA4499")
 tol11qualitative=c("#332288", "#6699CC", "#88CCEE", "#44AA99", "#117733", "#999933", "#DDCC77", "#661100", "#CC6677", "#882255", "#AA4499")
 tol12qualitative=c("#332288", "#6699CC", "#88CCEE", "#44AA99", "#117733", "#999933", "#DDCC77", "#661100", "#CC6677", "#AA4466", "#882255", "#AA4499")
 
pal(tol7qualitative)
```

A recent update to Paul’s technical paper adds a new banded rainbow scheme, and several have a large number of steps. He notes that when you’re using them you’re better off picking a scheme that matches the number of colors needed, rather than using only a few colors from a larger scheme.

```{r, eval=TRUE}
tol14rainbow=c("#882E72", "#B178A6", "#D6C1DE", "#1965B0", "#5289C7", "#7BAFDE", "#4EB265", "#90C987", "#CAE0AB", "#F7EE55", "#F6C141", "#F1932D", "#E8601C", "#DC050C")
tol15rainbow=c("#114477", "#4477AA", "#77AADD", "#117755", "#44AA88", "#99CCBB", "#777711", "#AAAA44", "#DDDD77", "#771111", "#AA4444", "#DD7777", "#771144", "#AA4477", "#DD77AA")
tol18rainbow=c("#771155", "#AA4488", "#CC99BB", "#114477", "#4477AA", "#77AADD", "#117777", "#44AAAA", "#77CCCC", "#777711", "#AAAA44", "#DDDD77", "#774411", "#AA7744", "#DDAA77", "#771122", "#AA4455", "#DD7788")
# ...and finally, the Paul Tol 21-color salute
tol21rainbow= c("#771155", "#AA4488", "#CC99BB", "#114477", "#4477AA", "#77AADD", "#117777", "#44AAAA", "#77CCCC", "#117744", "#44AA77", "#88CCAA", "#777711", "#AAAA44", "#DDDD77", "#774411", "#AA7744", "#DDAA77", "#771122", "#AA4455", "#DD7788")
 
pal(tol21rainbow)
```

Ok, I admit that 21 colors is pushing it when it comes to discernability on the screen or page. But sometimes there are too many lines anyway and you need to try to show them all. So this is a nice set to pull from your back pocket before reverting to a continuous series.

I’d be curious if you’ve found a color scheme you like – if so, add it to the comments…

**Palette From Comments**

```{r, eval=TRUE}
# Kevin Wright says
mycols=c("dodgerblue2", "#E31A1C", "green4", "#6A3D9A", "#FF7F00", "black",
"gold1", "skyblue2", "#FB9A99", "palegreen2", "#CAB2D6", "#FDBF6F",
"gray70", "khaki2", "maroon", "orchid1", "deeppink1", "blue1",
"steelblue4", "darkturquoise", "green1", "yellow4", "yellow3",
"darkorange4", "brown")

ones <- rep(1, length=length(mycols))
# Get hsv for labels
names(ones) <- apply(round(rgb2hsv(col2rgb(c(mycols))),2), 2,
function(x) {paste(x, collapse=", ")})
pie(ones, col=mycols, cex=.76, main = "HSV VALUES")
pal(mycols)
```

### Legends

```{r, eval=TRUE}
######################################################################
# plot with colors as groups
par(opar)
plot(mean.ann.temp,n.species,col=as.integer(as.factor(ecoregion)))
legend("topleft", inset=0.01, title="ecoregion",
       c("Acadian Plains","GL Lowlands"),
       pch=1,col=palette()[c(1,2)])

# plot with symbols as groups
par(xpd=NA) # suppress clipping
par(fig=c(0,1,0,0.75)) # move figure down in plot space

plot(mean.ann.temp,n.species,pch=as.integer(as.factor(ecoregion)))
legend(3,160, title="ecoregion",
       c("Acadian Plains","GL Lowlands",
         "NE Coastal", "NE Highlands", "Pine Barrens"),
       pch=1:5)
par(opar)
########################################################################
```

### Inset Figures

```{r, eval=TRUE}
par(opar)
set.seed(102)

####################################################
# create a stochastic increasing time series

x <- 1:1000
y <- rgamma(1000,shape=2,scale=1) + 0.01*x

###################################################
# select a time slice for plotting
slice <- 300:450

# create the main graph

par(mar=c(5,6,1,1))
plot(x[slice],y[slice],xlim=range(slice),col="gray",type="l",
     xlab="Time",ylab="Temperature",
     font.lab=2,cex.lab=1.5,las=1,ylim=range(y[slice]))

##################################################################
#add par commands to strip margins, overplot, and place the inset

par(new=TRUE) # overlay existing plot
par(mar=c(0,0,0,0)) # strip out the margins for the inset plot
par(fig=c(0.4,0.7,0.80,0.94)) # fig shrinks and places relative to figure region

#################################################################
# separately create the inset graph

plot(x,y,type="l",ann=FALSE)
rect(slice[1],-1,slice[length(slice)],1000,col="gray",border=NA)
box()
lines(x,y)

#########################################
par(opar)
```
### Miscellaneous Functions


```{r, eval=TRUE}
par(opar)
##############################################################
# Add formatted text to a plot
library(gplots)
par(mfrow=c(1,2))
plot(lat.centroid,n.species)
reg.model <- lm(n.species~lat.centroid)
abline(reg.model)

textplot(capture.output(summary(reg.model)))
par(opar)
##############################################################
# Add a boxed label to a plot
library(plotrix)
plot(lat.centroid,n.species)

# give x, y positions
boxed.labels(45.5,75,"boxed.labels",bg="gray90",cex=2)
###############################################################
# Add a text box to a plot
library(plotrix)


#give c(xmin,xmax), y top; # lines determined by amount of text
textbox(c(45.5,46.0),60,"this is a text box on several lines")
###############################################################
# stack the labels if they are too crowded
library(plotrix)
par(mar=c(8,4,4,2))
plot(lat.centroid,n.species,axes=FALSE)
axis(1,labels=FALSE)
axis(2)
box()
my.labs <-round(seq(41,47,by=0.25),3)
staxlab(1,at=my.labs) #add srt=45 to rotate
################################################################
# add an axis break
library(plotrix)
plot(lat.centroid,n.species)
axis.break(1)
par(opar)

```

### Graphics For Proteomics & Big Data  

```{r, eval=TRUE}
################################################
# Figure 1. standard pie chart
# data from Petricka et al. 2012 Fig 1D

Arab.labels <- c("Root Hairs", "Epidermis","Cortex",
                 "Endodermis","Vasculature", "Columella")
Protein.per <- c(34,8,9,8,29,12)
pie(Protein.per, labels=Arab.labels,main="Pie Chart",
    sub="Figure 1. A typical pie chart, which makes it hard to estimate proportions
    from the angles and does not preserve the original form of the data.
    Proportion data are taken from Petricka et al. (2012) Figure 1D.")

###############################################
# Figure 2. replotted as a bar chart
library(RColorBrewer)
Brew.cols <- brewer.pal(6,"Pastel1")
par(fig=c(0,1,0.3,1))
barplot(Protein.per,names.arg=Arab.labels,ylim=c(0,40),col=Brew.cols,
        ylab="% of Proteins",xlab="Cell Types", main = "Bar Plot")
mtext("Figure 2. A standard bar plot makes it easier to estimate the proportions, 
but is not practical for a large number of categories.", side= 1,line=10)
grid(nx=0,ny=8,col="gray")
par(opar)
##################################################################
# Figure 3. improved with a fan chart with RColorBrewer palette
library(plotrix)
library(RColorBrewer)
Brew.cols <- brewer.pal(6,"Pastel1")
par(fig=c(0,1,0.3,1))
fan.plot(Protein.per, labels = Arab.labels, col=Brew.cols, main="Fan Plot")
par(new=TRUE)
par(fig=c(0,1,0.3,1))
plot(Protein.per,type="n",font.sub=1,axes=FALSE, ann=FALSE)
mtext("Figure 3. A fan plot is an improvement over a pie chart because proportions 
can be estimated more accurately from the length of the arcs.", side= 1,line=6)
par(opar)
########################################################
#Figure 4. dotchart for long lists of elements
par(mar=c(9,4,4,2))
Protein.list = paste("Protein",1:50,"     ")
Express1 <- sort(runif(20,1,6))
Express2 <- sort(runif(20,3,12))
Express3 <- sort(runif(10,9,12))
Proteins <- c(Express1,Express2,Express3)
Grps <- factor(c(rep("Metabolic",20),rep("Chaperone",20),rep("Heat Shock",10)))
dotchart(Proteins,labels=Protein.list,,groups=Grps,xlab="Fold Induction",
         gcolor="red",pch=21,bg="gold",lcol="blue",cex=0.6, main="Dot Chart")
mtext("Figure 4. A dotchart efficiently displays 
quantitative values with labels and sorted groups",side=1,line=7)
par(opar)
##################################################
# Figure 5. plot showing polar coordinates
library(plotrix)
par(fig=c(0,1,0.2,1))
polar.plot(lengths=0,polar.pos=seq(135,240,length=6),
           main="Polar Plot",lwd=10,line.col=NA,
           radial.lim=c(0,40),start=0,rp.type="r",
           labels="",
           show.grid.labels=3,mar=c(2,4,7,2))

mtext("Figure 5. In a polar plot, each point is located within a circle.
The first coordinate is the angle (0-360), and the second coordinate
is the continuous variable (in this case, a scale from 0-40 units).", side= 1,line=6)
par(opar)
########################################
# Figure 6. Simple plot of protein numbers
library(plotrix)
par(fig=c(0,1,0.2,1))
polar.plot(lengths=Protein.per,polar.pos=seq(135,240,length=6),
           main="Polar Plot of Vectors",lwd=10,line.col=NA,
           radial.lim=c(0,40),start=0,rp.type="r",
           labels=Arab.labels,label.pos=seq(135,240,length=6),
           show.grid.labels=3,mar=c(2,4,7,2))
polar.plot(lengths=Protein.per,polar.pos=seq(135,240,length=6),
           add=TRUE, main="",lwd=10,line.col="seagreen",
           radial.lim=c(0,40),start=0,rp.type="r",
           labels=Arab.labels,label.pos=seq(135,240,length=6),
           show.grid.labels=3,mar=c(2,4,7,2),show.grid=FALSE,
           show.radial.grid=FALSE)
mtext("Figure 6. Protein numbers illustrated in a polar plot.
The relative proportions can be easily compared,
but the original units (numbers of proteins) are preserved.", side= 1,line=6)
par(opar)
#############################################################
# Figure 7. Now add a second set and color code for a new treatment
par(fig=c(0,1,0.2,1))
Protein2.per <- c(9,20,30,21,11,9)

polar.plot(lengths=c(Protein.per,Protein2.per),
           polar.pos=rep(seq(140,220,length=6),2)+rep(c(0,180),each=6),
           lwd=10,line.col=rep(c("seagreen","goldenrod"),each=6),
           radial.lim=c(0,40),start=0,rp.type="r",
           labels=Arab.labels,
           label.pos=rep(seq(140,220,length=6),2)+rep(c(0,180),each=6),
           show.grid.labels=3,mar=c(2,4,7,4),cex=2)



           mtext("Control",side=2,font=2,las=1,cex=1.5,line=3,at=30)
           mtext("Ectopic",side=4,font=2,las=1,cex=1.5,line=3,at=30)
           mtext("Polar Plot\nWith Two Groups",side=3,font=2,las=1,cex=1.75,line=1,
                 at=0)
mtext("Figure 7. Comparison of two groups in a polar plot.
With exactly 2 groups, the vectors can be extended and color coded
to illustrate comparisons within and between groups.", side= 1,line=6)
par(opar)
#####################################################
# Figure 8. Create a graph for 100 proteins, with 4 proteins coded
par(fig=c(0,1,0.2,1))
Protein.col <- rep("black",100)
Protein.col[c(60, 70, 93,95)] <- "red"  
Protein.express <- sort(rgamma(100,shape=1,scale=3))
polar.plot(lengths=Protein.express, 
           polar.pos=seq(10,350,length=100),
           lwd=2,line.col=Protein.col,
           radial.lim=c(0,max(Protein.express)),start=0,rp.type="r",
           show.grid.labels=4,mar=c(2,4,7,4),cex=2)
mtext("Polar Plot\nOf 100 ER Proteins",side=3,font=2,las=1,cex=1.75,line=2,
      at=0)
par(opar)
mtext("Figure 8. Peptide composition of individual proteins.
Each line represents the expression of an individual protein. 
The proteins are ordered by expression intensity,
with 4 particular proteins (#60,70,93,95) highlighted.", side= 1,line=2)
par(opar)
#############################################################
# Figure 9. Create a graph for 100 proteins, with special coding for peptide number
par(fig=c(0,1,0.2,1))

library(RColorBrewer)
my.reds <- brewer.pal(6,"Reds")
red6 <- sample(my.reds,100,replace=TRUE,prob=6:1)
Protein.express <- sort(rgamma(100,shape=1,scale=3))
Protein.express <- runif(100,0,12)
polar.plot(lengths=Protein.express,
           polar.pos=seq(10,350,length=100),
           lwd=3,line.col=red6,
           radial.lim=c(0,max(Protein.express)),start=0,rp.type="r",
           labels="",
           show.grid.labels=4,mar=c(2,4,7,4),cex=2)
mtext("Normalized Fold Induction\nOf 100 ER Proteins",side=3,font=2,las=1,cex=1.75,line=1,
      at=0)
legend(-35,15,pt.cex=1.2,legend=c("1 peptide","2 peptides","3 peptides",
                       "4 peptides", "5-10 peptides","> 10 peptides"),
       fill=my.reds)
mtext("Figure 9. Peptide composition of individual proteins.
Each line represents the expression of an individual protein. 
The ordering is arbitrary, but colors show number of peptides
used in the protein identification.", side= 1,line=4)
par(opar)

####################################################
# Figure 10. mosaic plot for two categorical variables
library(RColorBrewer)
my.blues <- brewer.pal(4,"Blues")
Protein.counts <- matrix(c(100,25,300,40,60,4,200,22,48,20,99,777),nrow=3,
     dimnames=list(c("Control","Enriched","Disturbed"),c("1 peptide","2 peptides",
                    "3 peptides", "> 3 peptides")))
mosaicplot(t(Protein.counts),col=my.blues,main="Mosaic Plot Of Protein Counts")
mtext("Figure 10. Protein composition as a function of 
experimental treatment. Heights are proportional to protein numbers in each treatment,
and widths are proportional to the number of peptides in each protein. Tile areas
are proportional to the number of proteins in each grouping.", side= 1,line=4)
par(opar)
```

