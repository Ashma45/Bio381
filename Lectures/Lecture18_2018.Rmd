---
title: 'Lecture #18: Control Structures III'
author: "Nicholas J. Gotelli"
date: "March 27, 2018"
output:
  html_document:
    highlight: tango
    theme: united
  pdf_document: default
---
### Tip #6: Use `break` to set up a conditional to break out of loop early

```{r, eval=FALSE}
# create a simple random growth population model function

##################################################
# FUNCTION: RanWalk
# stochastic random walk 
# input: times = number of time steps
#        n1 = initial population size (= n[1])
#        lambda = finite rate of increase
#        noiseSD = sd of a normal distribution with mean 0
# output: vector n with population sizes > 0 
#         until extinction, then NA 
#------------------------------------------------- 
library(tcltk)
RanWalk <- function(times=100,n1=50,lambda=1.00,noiseSD=10) {
                n <- rep(NA,times)  # create output vector
                n[1] <- n1 # initialize with starting population size
                noise <- rnorm(n=times,mean=0,sd=noiseSD) # create noise vector
                for(i in 1:(times-1)) {
                  n[i + 1] <- lambda*n[i] + noise[i]
                  if(n[i + 1] <=0) {
                    n[i + 1] <- NA
                    cat("Population extinction at time",i-1,"\n")
                    # tkbell()
                    break}
                }

return(n)
}

# explore paramaters in plot function
plot(RanWalk(),type="o")
plot(RanWalk(lambda=1.00,noiseSD=0),type="o")
```

### Using double for loops

```{r, eval=FALSE}
m <- matrix(round(runif(20),digits=3),nrow=5)
# loop over rows
for (i in 1:nrow(m)) {
  m[i,] <- m[i,] + i
} 
print(m)

# Loop over columns
m <- matrix(round(runif(20),digits=3),nrow=5)
for (j in 1:ncol(m)) {
  m[,j] <- m[,j] + j
}
print(m)

# Loop over rows and columns
m <- matrix(round(runif(20),digits=3),nrow=5)
for (i in 1:nrow(m)) {
  for (j in 1:ncol(m)) {
    m[i,j] <- m[i,j] + i + j
  } # end of column j loop
} # end or row i loop
 print(m) 
```
### Writing functions for equations and sweeping over parameters

```{r, eval=TRUE}
# S = cA^z species area function, but what does it look like??

##################################################
# function: SpeciesAreaCurve
# creates power function relationship for S and A
# input: A is a vector of island areas
#        c is the intercept constant
#        z is the slope constant
# output: S is a vector of species richness values
#------------------------------------------------- 
SpeciesAreaCurve <- function(A=1:5000,c= 0.5,z=0.26){
  
  S <- c*(A^z)
return(S)
}
head(SpeciesAreaCurve())

##################################################
# function: SpeciesAreaPlot
# plot species area curves with parameter values
# input: A = vector of areas
#        c = single value for c parameter
#        z = single value for z parameter

# output: smoothed curve with parameters in graph
#------------------------------------------------- 
SpeciesAreaPlot <- function(A=1:5000,c= 0.5,z=0.26) {
plot(x=A,y=SpeciesAreaCurve(A,c,z),type="l",xlab="Island Area",ylab="S",ylim=c(0,1000))
mtext(paste("c =", c,"  z =",z),cex=0.7) 
      return()
}
SpeciesAreaPlot()
```
### Now build a grid of plots!
```{r}
# global variables
cPars <- c(100,150,175)
zPars <- c(0.10, 0.16, 0.26, 0.3)
par(mfrow=c(3,4))
for (i in seq_along(cPars)) {
  for (j in seq_along(zPars)) {
    SpeciesAreaPlot(c=cPars[i],z=zPars[j])
  }
} 
```
### Looping with `while` or `repeat`
```{r, eval=FALSE}
# looping with for
cutPoint <- 0.1
z <- NA
ranData <- runif(100)
for (i in seq_along(ranData)) {
 z <- ranData[i]
 if (z < cutPoint) break
}
print(z)

# looping with while

z <- NA
cycleNumber <- 0
while (is.na(z) | z >= cutPoint) {
  z <- runif(1)
  cycleNumber <- cycleNumber + 1
  
}
print(z)
print(cycleNumber)

# looping with repeat

z <- NA
cycleNumber <- 0

repeat {
  z <- runif(1)
cycleNumber <- cycleNumber + 1
  
  if (z <= cutPoint) break
}
print(z)
print(cycleNumber)

# add code for cycle number
# try setting limit to 0.001

# 
  
   
```

### Using the `expand.grid()` function to create a dataframe with parameter combinations

```{r}

expand.grid(cPars,zPars)

##################################################
# function: SA_Output
# Summary stats for species-area power function
# input: vector of predicted species richness 
# output: list of max-min, coefficient of variation 
#------------------------------------------------- 
SA_Output <- function(S=runif(1:10)) {

sumStats <- list(SGain=max(S)-min(S),SCV=sd(S)/mean(S))

return(sumStats)
}
SA_Output()

# Build program body with a single loop through 
# the parameters in modelFrame

# Global variables
Area <- 1:5000
cPars <- c(100,150,175)
zPars <- c(0.10, 0.16, 0.26, 0.3)

# set up model frame
modelFrame <- expand.grid(c=cPars,z=zPars)
modelFrame$SGain <- NA
modelFrame$SCV <- NA
print(modelFrame)

# cycle through model calculations
for (i in 1:nrow(modelFrame)) {
  
  # generate S vector
  temp1 <- SpeciesAreaCurve(A=Area,
                            c=modelFrame[i,1],
                            z=modelFrame[i,2])
  # calculate output stats
  temp2 <- SA_Output(temp1)
  # pass results to columns in data frame
  modelFrame[i,c(3,4)] <- temp2
  
}
print(modelFrame)

# use cex expansion to show a third variable with symbol size
plot(x=modelFrame$c,y=modelFrame$SGain,cex=10*modelFrame$z)
```

## Batch processing

### Build a set of random files
```{r}
##################################################
# function: FileBuilder
# create a set of random files for regression
# input: fileN = number of files to create
#       : fileFolder = name of folder for random files
#       : fileSize = c(min,max) number of rows in file
#       : fileNA = number on average of NA values per column
# output: set of random files
#------------------------------------------------- 
FileBuilder <- function(fileN=10,
                        fileFolder="RandomFiles/",
                        fileSize=c(15,100),
                        fileNA=3){
for (i in seq_len(fileN)) {
fileLength <- sample(fileSize[1]:fileSize[2],size=1) # get number of rows
varX <- runif(fileLength) # create random x
varY <- runif(fileLength) # create randon y
dF <- data.frame(varX,varY) # bind into a data frame
badVals <- rpois(n=1,lambda=fileNA) # determine NA number
dF[sample(nrow(dF),size=badVals),1] <- NA # random NA in varX
dF[sample(nrow(dF),size=badVals),2] <- NA # random NA in varY

# create label for file name with padded zeroes
fileLabel <- paste(fileFolder,
                       "ranFile",
                       formatC(i,
                       width=3,
                       format="d",
                       flag="0"),
                       ".csv",sep="")

# set up data file and incorporate time stamp and minimal metadata
write.table(cat("# Simulated random data file for batch processing","\n",
                    "# timestamp: ",as.character(Sys.time()),"\n",
                    "# NJG","\n",
                    "# ------------------------", "\n",
                    "\n",
                    file=fileLabel,
                    row.names="",
                    col.names="",
                    sep=""))

# now add the data frame
write.table(x=dF,
            file=fileLabel,
            sep=",",
            row.names=FALSE,
            append=TRUE)


}
}
```
### Run regression model and extract stats

```{r}

##################################################
# function: regStats
# fits linear model, extracts statistics
# input: 2-column data frame (x and y)
# output: slope, p-value, and r2
#------------------------------------------------- 
regStats <- function(d=NULL) {
             if(is.null(d)) {
               xVar <- runif(10)
               yVar <- runif(10)
               d <- data.frame(xVar,yVar)
             }
  . <- lm(data=d,d[,2]~d[,1])
  . <- summary(.)
  statsList <- list(Slope=.$coefficients[2,1],
                    pVal=.$coefficients[2,4],
                    r2=.$r.squared)
  return(statsList)

}
```

### Body of script for batch processing of regression models
```{r, warning=FALSE}
library(TeachingDemos)
char2seed("Freezing March")

#--------------------------------------------
# Global variables
fileFolder <- "RandomFiles/"
nFiles <- 100
fileOut <- "StatsSummary.csv"
#--------------------------------------------

# Create 100 random data sets
FileBuilder(fileN=nFiles)
fileNames <- list.files(path=fileFolder)

# Create data frame to hold file summary statistics
ID <- seq_along(fileNames)
fileName <- fileNames
slope <- rep(NA,nFiles)
pVal <- rep(NA,nFiles)
r2 <- rep(NA,nFiles)

statsOut <- data.frame(ID,fileName,slope,pVal,r2)

# batch process by looping through individual files
for (i in seq_along(fileNames)) {
  data <- read.table(file=paste(fileFolder,fileNames[i],sep=""),
                     sep=",",
                     header=TRUE) # read in next data file
  
  dClean <- data[complete.cases(data),] # get clean cases
  
  . <- regStats(dClean) # pull regression stats from clean file
  statsOut[i,3:5] <- unlist(.) # unlist, copy into last 3 columns
  
}
# set up output file and incorporate time stamp and minimal metadata
  write.table(cat("# Summary stats for ",
                    "batch processing of regression models","\n",
                    "# timestamp: ",as.character(Sys.time()),"\n",
                    "# NJG","\n",
                    "# ------------------------", "\n",
                    "\n",
                    file=fileOut,
                    row.names="",
                    col.names="",
                    sep=""))
  
# now add the data frame
  write.table(x=statsOut,
              file=fileOut,
              row.names=FALSE,
              col.names=TRUE,
              sep=",",
              append=TRUE)

```

