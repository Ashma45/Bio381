---
title: 'Lecture #19: Control Structures IV'
author: "Nicholas J. Gotelli"
date: "April 6, 2017"
output:
  html_document:
    highlight: tango
    keep_md: yes
    theme: united
  pdf_document: default
---
```{r, eval=FALSE}
# S = cA^z species area function, but what does it look like??

##################################################
# function: SpeciesAreaCurve
# creates power function relationship for S and A
# input: A is a vector of island areas
#        c is the intercept constant
#        z is the slope constant
# output: S is a vector of species richness values
#------------------------------------------------- 
SpeciesAreaCurve <- function(A=1:5000,c= 0.5,z=0.26){
  
  S <- c*(A^z)
return(S)
}
head(SpeciesAreaCurve())
```

### Using the `expand.grid()` function to create a dataframe with parameter combinations

```{r, eval=FALSE}
cPars <- c(100,150,175)
zPars <- c(0.10, 0.16, 0.26, 0.3)
expand.grid(cPars,zPars)
```

### Building your own "expand grid" function

```{r, eval=FALSE}
##################################################
# function: myExpandGrid
# create expand.grid from base functions
# input: 2 atomic vectors of any length
# output: data frame
#------------------------------------------------- 
myExpandGrid <- function(a=1:4,b=c(300,400,500)) {
Factor1 <- rep(a,times=length(b))
Factor2 <- rep(b,each=length(a))
return(list(varA=Factor1,varB=Factor2))
}
myExpandGrid()
```


### Extract output from SpeciesArea

```{r,eval=FALSE}
##################################################
# function: SA_Output
# Summary stats for species-area power function
# input: vector of predicted species richness 
# output: list of max-min, coefficient of variation 
#------------------------------------------------- 
SA_Output <- function(S=runif(1:10)) {

sumStats <- list(SGain=max(S)-min(S),SCV=sd(S)/mean(S))

return(sumStats)
}
SA_Output()
```

### Build program body with a single loop through the parameters in modelFrame

```{r,eval=FALSE}
# Global variables
Area <- 1:5000
cPars <- c(100,150,175)
zPars <- c(0.10, 0.16, 0.26, 0.3)

# set up model frame
modelFrame <- expand.grid(c=cPars,z=zPars)
modelFrame$SGain <- NA
modelFrame$SCV <- NA
print(modelFrame)

# cycle through model calculations
for (i in 1:nrow(modelFrame)) {
  
  # generate S vector
  temp1 <- SpeciesAreaCurve(A=Area,
                            c=modelFrame[i,1],
                            z=modelFrame[i,2])
  # calculate output stats
  temp2 <- SA_Output(temp1)
  # pass results to columns in data frame
  modelFrame[i,c(3,4)] <- temp2
  
}
print(modelFrame)

# use cex expansion to show a third variable with symbol size
plot(x=modelFrame$c,y=modelFrame$SGain,cex=10*modelFrame$z)
```


### Sweeping parameters for replication of a stochastic model

```{r, eval=FALSE}
# create a simple random growth population model function

##################################################
# FUNCTION: RanWalk
# stochastic random walk 
# input: times = number of time steps
#        n1 = initial population size (= n[1])
#        lambda = finite rate of increase
#        noiseSD = sd of a normal distribution with mean 0
# output: vector n with population sizes > 0 
#         until extinction, then NA 
#------------------------------------------------- 
library(tcltk)
RanWalk <- function(times=100,n1=50,lambda=1.00,noiseSD=10) {
                n <- rep(NA,times)  # create output vector
                n[1] <- n1 # initialize with starting population size
                noise <- rnorm(n=times,mean=0,sd=noiseSD) # create noise vector
                for(i in 1:(times-1)) {
                  n[i + 1] <- lambda*n[i] + noise[i]
                  if(n[i + 1] <=0) {
                    n[i + 1] <- NA
#                    cat("Population extinction at time",i-1,"\n")
                    # tkbell()
                    break}
                }

return(n)
}
```

```{r, eval=FALSE}
##################################################
# function: rWalkOutput
# summarizes univariate metric to describe population trajectory
# input: vector of population sizes generated by population model
# output: length of positive elements in vector
#------------------------------------------------- 
rWalkOutput <- function(v=c(1:10,c(NA,NA))) {
lenPop <- length(v[is.na(v)==FALSE])

return(lenPop)
}
##################################################
# function: rWalkOutput2
# summarizes univariate metric to describe population trajectory
# input: vector of population sizes generated by population model
# output: length of positive elements in vector
#------------------------------------------------- 
rWalkOutput2 <- function(v=c(1:10,c(NA,NA))) {
lenPop <- max(v[is.na(v)==FALSE])

return(lenPop)
}
# global variables
SerLen = 500 # length of each time series
lambda <- c(0.95, 0.99, 1.00, 1.01, 1.05) # constant multiplier
noiseSD <- c(0,5,10,20) # sd of Gaussian noise
n1 <- 50 # initial population size
reps <- 20 # number of replicates per treatment combination

# create output structure
ranOut <- expand.grid(n1=n1,reps=reps, SerLen=SerLen,lambda=lambda,noiseSD=noiseSD)

# add summary response variables
ranOut$meanLen <- NA
ranOut$sdLen <- NA
SurvTime <- rep(NA,reps) # vector to hold survival times
print(ranOut)

# begin program body
for (i in 1:nrow(ranOut)) { # start parameter loop
  for (j in 1:reps) { # start individual replicate loop
  temp <- RanWalk(times=ranOut$SerLen[i],
                   n1=ranOut$n1[i],
                   lambda=ranOut$lambda[i], 
                   noiseSD=ranOut$noiseSD[i])
  SurvTime[j] <- rWalkOutput2(temp) # operate on time series for series in temp
                        
  } # end individual replicate loop
  
  # now get mean and sd of the vector of the response variable
  ranOut$meanLen[i] <- mean(SurvTime)
  ranOut$sdLen[i] <- sd(SurvTime)
  
} # end of parameter loop
print(ranOut)
```
### quickly change the program with a new output variable!

